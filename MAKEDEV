#! /bin/sh -

# $Id: MAKEDEV,v 1.1 1993/07/19 11:31:32 alfie Exp alfie $
#
# This is my attempt at a MAKEDEV script.  IMHO it cleans up many areas.
# It can be used to determine the necessary info for a device without
# actually creating it using the '-n' flag.
#
# It is based (heavily) on Jim Winstead's version and my main source of
# information has been Rick Miller's Linux device list.
#
# It makes less individual devices and tends to make classes of devices
# (eg "MAKEDEV hda" will create "hda" and the 8 partitions; "MAKEDEV ptyp"
# will create the ptyp[0-f] master and ttyp[0-f] slave devices).
#
# The group used for the devices are changeable at the head of the script,
# so you can edit these to match the groups on your system, or your whims.
#
# Thanks to Ian Jackson for help and encouragement.
# 
# 	Nick Holloway <alfie@dcs.warwick.ac.uk>  19th July 1993
# 
# TODO: 
#   o would like cleaner naming for virtual terminals -- suggestions?.
#     Also, to create them in one entry (as done with others).
#   o Campaign for removal of ttySn for serial lines :-).
#   o more understanding of the various NET devices, and confidence that
#     nothing is missing from that set.
# 
#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#
# Device 'make' file.  Valid arguments:
# 
#	generic		create a generic subset of devices
#	local		configuration specific devices (runs MAKEDEV.local)
# 	std		standard devices
#  Virtual Terminals:
#	console		(also known as tty0)
#	tty{0..63}	virtual consoles
#  Serial devices:
#	ttyS{0..63}	serial ports and corresponding dialout device
#  Pseudo Terminals:
#	pty[p-s]	banks of of master and slave pseudo terminals
#  Parallel ports:
#	par[0-3]	parallel ports
#	lp[0-3]		   ""     ""
#  Bus Mice:
#	busmice		various bus mice
#  Joystick:
#	js		joystick
#  Disks:
#	fd[0-4]		floppy disks
#	hd[a-d]		AT hard disks (1st controller)
#	hd1[a-d]	2nd AT controller hard disks
#	xd[a-d] 	XT hard disks
#	sd[a-i]		SCSI hard disks
#  Tapes:
#	st[0-1]		SCSI tapes
#	qic		QIC tapes
#  CD:
#	scd[0-1]	SCSI CD players
#	sonycd		Sony CD player
#	mcd		Mitsumi CD player
#  Networking:
#	net		various protocol control devices (?)
#	we,wd,ec,ne	various net interfaces (?)
#  Audio:
#	audio		various audio devices
#  Misc:
#	fd		file names for file descriptors
#
#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#

# Define what group a collection of devices will be created with

 system=system
   kmem=kmem
    tty=tty
dialout=dialout
  mouse=system
printer=daemon
 floppy=floppy
   disk=disk
     cd=disk
   tape=disk
    net=system
  audio=system

#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#

makedev () {	# usage: makedev name [bcu] major minor owner:group mode
	rm -f $1
	mknod $1 $2 $3 $4 &&
	chown $5 $1 &&
	chmod $6 $1
}

debug=
if [ _"-n" = _"$1" ]
then
	shift 
	debug=-n
	makedev () { 
	echo "$1 = $2 $3 $4 $5 $6" 
	}
fi


for arg
do
	case $arg in
	generic)
		sh $0 $debug std
		sh $0 $debug fd0 fd1
		sh $0 $debug hda hdb
		sh $0 $debug xda xdb
		sh $0 $debug sda sdb
		sh $0 $debug ptyp ptyq ptyr ptys
		sh $0 $debug console tty1 tty2 tty3 tty4 tty5 tty6 tty7 tty8
		sh $0 $debug ttyS0 ttyS1 ttyS2 ttyS3
		sh $0 $debug busmice
		sh $0 $debug lp0 lp1 lp2
		sh $0 $debug par0 par1 par2
		;;
	local)
		sh $0.local $debug
		;;
	std)
		makedev mem  c 1 1 root:$kmem   660
		makedev kmem c 1 2 root:$kmem   660
		makedev null c 1 3 root:$system 666
		makedev port c 1 4 root:$kmem   660
		makedev zero c 1 5 root:$system 666
		makedev core c 1 6 root:$kmem   660
		makedev full c 1 7 root:$system 666
		makedev ram  b 1 1 root:$disk   660
		makedev tty  c 5 0 root:$tty    666
		;;
	console)
		makedev console c 4 0 root:$tty 622
		;;
	tty[0-9]|tty[1-5][0-9]|tty[6][0-3])
		num=`expr $arg : "tty\(.*\)"`
		makedev tty$num c 4 $num root:$tty 622
		;;
	ttyS[0-9]|ttyS[1-5][0-9]|ttyS[6][0-3])
		# OK, I don't personally like this, and believe it will cause
		# grief when pty's are expanded, but the current dogma is
		# for serial lines to be named "ttyS<n>" (0<=n<=63).
		line=`expr $arg : "ttyS\(.*\)"`
		minor=`expr 64 + $line`
		makedev ttyS$line c 4 $minor root:$tty 666
		makedev cua$line c 5 $minor root:$dialout 660
		;;
#	tty[abcd])			# Standard com1 to com4
#		line=`expr $arg : "tty\(.\)"`
#		minor=`expr 64 + abcd : ".*$line" - 1`
#		makedev tty$line c 4 $minor root:$tty 666
#		makedev cua$line c 5 $minor root:$dialout 660
#		;;
#	tty[ef][0-9a-f])		# extra serial lines
#		bank=`expr $arg : "tty\(.\)`
#		line=`expr $arg : "tty.\(.\)`
#		base=`expr ef : ".*$bank" - 1 \* 16`
#		minor=`expr 68 + $base + 0123456789abcdef : ".*$line" - 1`
#		makedev tty$bank$line c 4 $minor root:$tty 666
#		makedev cua$bank$line c 4 $minor root:$dialout 660
#		;;
	pty[p-s])
		# Currently limited to 64 master/slave pairs.  When (if?)
		# pty's master and slaves are each moved to their own major 
		# device, this can be updated to allow 256 pairs [p-zP-T].
		bank=`expr $arg : "pty\(.\)"`
		base=`expr \( pqrs : ".*$bank" - 1 \) \* 16`
		for i in 0 1 2 3 4 5 6 7 8 9 a b c d e f
		do
			j=`expr 0123456789abcdef : ".*$i" - 1`
			makedev pty$bank$i c 4 `expr 128 + $base + $j` root:$tty 666
			makedev tty$bank$i c 4 `expr 192 + $base + $j` root:$tty 666
		done
		;;
	par[0-2])
		port=`expr $arg : "par\(.\)"`
		makedev $arg c 6 $port root:$printer 660 
		;;
	lp[0-2])
		port=`expr $arg : "lp\(.\)"`
		makedev $arg c 6 $port root:$printer 660 
		;;
	busmice)
		makedev logibm   c 10 0 root:$mouse 666
		makedev psaux    c 10 1 root:$mouse 666
		makedev inportbm c 10 2 root:$mouse 666
		makedev atibm    c 10 3 root:$mouse 666
		;;
		js)
			makedev js0 c 15 0 root:$mouse 666
			makedev js1 c 15 1 root:$mouse 666
			;;
	fd[0-4])
		disk=`expr $arg : "fd\(.\)"`
		makedev fd$disk b 2 $disk root:$floppy 660
		makedev fd${disk}d360  b 2 `expr $disk +  4` root:$floppy 660
		makedev fd${disk}h1200 b 2 `expr $disk +  8` root:$floppy 660
		makedev fd${disk}D360  b 2 `expr $disk + 12` root:$floppy 660
		makedev fd${disk}H360  b 2 `expr $disk + 12` root:$floppy 660
		makedev fd${disk}D720  b 2 `expr $disk + 16` root:$floppy 660
		makedev fd${disk}H720  b 2 `expr $disk + 16` root:$floppy 660
		makedev fd${disk}h360  b 2 `expr $disk + 20` root:$floppy 660
		makedev fd${disk}h720  b 2 `expr $disk + 24` root:$floppy 660
		makedev fd${disk}H1440 b 2 `expr $disk + 28` root:$floppy 660
		;;
	hd[a-d])
		disk=`expr $arg : "hd\(.\)"`
		base=`expr \( abcd : ".*$disk" - 1 \) \* 64`
		makedev hd$disk b 3 $base root:$disk 660
		for part in 1 2 3 4 5 6 7 8 # 9 10 11 12 13 14 15 16
		do
		makedev hd$disk$part b 3 `expr $base + $part` root:$disk 660
		done
		;;
	hd1[a-d])
		disk=`expr $arg : "hd1\(.\)"`
		base=`expr \( abcd : ".*$disk" - 1 \) \* 64`
		makedev hd1$disk b 22 $base root:$disk 660
		for part in 1 2 3 4 5 6 7 8 # 9 10 11 12 13 14 15 16
		do
		makedev hd1$disk$part b 22 `expr $base + $part` root:$disk 660
		done
		;;
	xd[a-d])
		disk=`expr $arg : "xd\(.\)"`
		base=`expr \( abcd : ".*$disk" - 1 \) \* 64`
		makedev xd$disk b 13 $base root:$disk 660
		for part in 1 2 3 4 5 6 7 8 # 9 10 11 12 13 14 15 16
		do
		makedev xd$disk$part b 13 `expr $base + $part` root:$disk 660
		done
		;;
	sd[a-h])
		disk=`expr $arg : "sd\(.\)"`
		base=`expr \( abcdefgh : ".*$disk" - 1 \) \* 16`
		makedev sd$disk b 8 $base root:$disk 660
		for part in 1 2 3 4 5 6 7 8 # 9 10 11 12 13 14 15
		do
		makedev sd$disk$part b 8 `expr $base + $part` root:$disk 660
		done
		;;
	st[0-1])
		tape=`expr $arg : "st\(.\)"`
		makedev st$tape c 9 $tape root:$floppy 660
		makedev nst$tape c 9 `expr 128 + $tape` root:$floppy 660
		;;
	qic)
		makedev rmt8       c 12   6 root:$tape 660
		makedev rmt16      c 12   8 root:$tape 660
		makedev tape-d     c 12 136 root:$tape 660
		makedev tape-reset c 12 255 root:$tape 660
		;;
	scd[0-1])
		cdrom=`expr $arg : "scd\(.\)"`
		makedev scd$cdrom c 11 $cdrom root:$cd 660
		;;
	sonycd)
		makedev $arg b 21 0 root:$cd 660
		;;
	mcd)
		makedev $arg b 23 0 root:$cd 660
		;;
	net)
		makedev socket   c 16 0 root:$net 600
		makedev arp      c 16 1 root:$net 600
		makedev unix     c 17 0 root:$net 600
		makedev inet     c 18 0 root:$net 600
		makedev ip       c 18 1 root:$net 600
		makedev icmp     c 18 2 root:$net 600
		makedev tcp      c 18 3 root:$net 600
		makedev udp      c 18 4 root:$net 600
		;;
	we[0-3])
		part=`expr $arg : "we\(.\)"`
		makedev $arg c 19 $part root:$net 600
		;;
	wd[0-3])
		part=`expr $arg : "wd\(.\)"`
		makedev $arg c 20 $part root:$net 600
		;;
	ec[0-3])
		part=`expr $arg : "ec\(.\)"`
		makedev $arg c 20 `expr 8 + $part` root:$net 600
		;;
	ne[0-3])
		part=`expr $arg : "ne\(.\)"`
		makedev $arg c 20 `expr 16 + $part` root:$net 600
		;;
	audio)
		makedev mixer     c 14 0 root:$audio 666
		makedev sequencer c 14 1 root:$audio 666
		makedev midi      c 14 2 root:$audio 666
		makedev dsp       c 14 3 root:$audio 666
		makedev audio     c 14 4 root:$audio 666
		;;
	fd)
		# not really devices, we use the /proc filesystem
		ln -sf /proc/self/fd fd 
		ln -sf fd/0 stdin
		ln -sf fd/1 stdout
		ln -sf fd/2 stderr
		;;
	*)
		echo "don't know how to make device \"$arg\"" >&2
		;;
	esac
done

exit 0
